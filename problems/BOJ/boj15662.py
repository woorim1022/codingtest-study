# 문제
# 총 8개의 톱니를 가지고 있는 톱니바퀴 T개가 아래 그림과 같이 일렬로 놓여져 있다.
# 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데,
# 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, ..., 가장 오른쪽 톱니바퀴는 T번이다.
# 아래 그림은 T가 4인 경우이다.
#
# 이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다.
# 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다.
#
# 톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때,
# 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다.
# 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면,
# B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자.
#
# 두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다.
# 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다.
# 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고,
# 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서,
# 아래 그림과 같은 모양을 만들게 된다.
#
# 위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면,
# 2번 톱니바퀴가 반시계 방향으로 회전하게 되고,
# 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만,
# 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다.
#

# 톱니바퀴 T개의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때,
# 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.


# 입력
# 첫째 줄에 톱니바퀴의 개수 T (1 ≤ T ≤ 1,000)가 주어진다.
#
# 둘째 줄부터 T개의 줄에 톱니바퀴의 상태가 가장 왼쪽 톱니바퀴부터 순서대로 주어진다.
# 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다.
# N극은 0, S극은 1로 나타나있다.
#
# 다음 줄에는 회전 횟수 K(1 ≤ K ≤ 1,000)가 주어진다.
# 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다.
# 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호,
# 두 번째 정수는 방향이다.
# 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.
#
# 출력
# 총 K번 회전시킨 이후에 12시방향이 S극인 톱니바퀴의 개수를 출력한다.
#
# 예제 입력 1
# 4         (톱니바퀴 개수 1 ≤ T ≤ 1,000)
# 10101111  (톱니바퀴의 상태, 12시방향부터 시계방향 순서)
# 01111101
# 11001110
# 00000010
# 2         (회전 횟수 1 ≤ K ≤ 1,000)
# 3 -1 (회전시킨 방법, 회전시킨 톱니바퀴의 번호,  두 번째 정수는 방향이다.)
# 1 1
# 예제 출력 1
# 3




# 왼쪽 톱니바퀴의 3번째 톱니가 오른쪽 톱니의 7번째 톱니와 맞닿아있음
# 회전시킬 톱니바퀴의 번호로 이동해서 3, 7번째 톱니 번호 확인하고 나머지 톱니바퀴의 번호도 확인
# 회전바퀴 번호 n의 3번째,(n[2])!=n+1[6] 7번째(n[6])!=n-1[2]
#  for 문 2개 만들어서 첫 바퀴의 각각 왼쪽, 오른쪽으로 이동해 가며 움직임 여부 체크
# n이 1이면, n+-홀수는 -1, n+-짝수는 1(시계방향)
# 시계방향, 반시계방향인지 구해서 톱니 배열 순서 바꿔줌(큐 사용)



from collections import deque


def move_gear(idx, cur_dir):
    # idx : 현재 톱니바퀴의 index번호
    global cur_right, cur_left, gears
    # 현재 톱니바퀴의 회전방향
    origin_dir = cur_dir

    # 현재 톱니바퀴를 기준으로 좌측의 톱니바퀴들 확인.
    # reversed(range(idx)) : idx-1 부터 0까지 하나씩 감소
    for i in reversed(range(idx)):
        # 서로 다른 극이면
        if cur_right != gears[i][LEFT]:
            cur_right = gears[i][RIGHT]
            # 현재 톱니바퀴와 반대방향으로 회전하므로 -1 곱해줌
            gears[i].rotate(cur_dir * -1)
            cur_dir *= -1
        # 서로 같은 극이면
        # 이후의 톱니바퀴도 회전하지 않으므로 이동할 필요 없음
        # break로 for문을 벗어난다.
        else:
            break

    cur_dir = origin_dir
    # 현재 톱니바퀴를 기준으로 우측의 톱니바퀴들 확인.
    for i in range(idx + 1, t):
        if gears[i][RIGHT] != cur_left:
            cur_left = gears[i][LEFT]
            gears[i].rotate(cur_dir * -1)
            cur_dir *= -1
        else:
            break


LEFT, RIGHT = 2, 6
t = int(input())
# 전역변수 gears
gears = [deque(map(int, input().strip())) for _ in range(t)]
k = int(input())
orders = [list(map(int, input().split())) for _ in range(k)]

for gear_idx, direction in orders:
    # index는 0부터 시작이므로 바퀴 번호에서 1 빼준다.
    gear_idx -= 1
    # 회전시킬 바퀴의 2,6번 index를 가져온다. 전역변수에 저장
    cur_left, cur_right = gears[gear_idx][LEFT], gears[gear_idx][RIGHT]
    # 회전시킬 바퀴를 주어진 방향으로 회전시킨다.
    gears[gear_idx].rotate(direction)
    # 현재 톱니바퀴 좌, 우의 톱니바퀴들을 회전시키는 함수
    move_gear(gear_idx, direction)

# enumerate(gears) : gears 리스트에서 인덱스 값을 포함하는 enumerate 객체 반환
# print(list(enumerate(gears))) : [(0, deque([1, 1, 0, 1, 0, 1, 1, 1])), (1, deque([1, 1, 1, 1, 1, 0, 1, 0])), (2, deque([1, 1, 0, 0, 1, 1, 1, 0])), (3, deque([0, 0, 0, 0, 0, 0, 0, 1]))]
print(sum([1 if gear[0] else 0 for delta, gear in enumerate(gears)]))














